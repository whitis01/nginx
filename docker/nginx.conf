
#user  nobody;
worker_processes  1;

#error_log  logs/error.log;
#error_log  logs/error.log  notice;
#error_log  logs/error.log  info;

#pid        logs/nginx.pid;


events {
    worker_connections  1024;
}


http {
    include       mime.types;
    default_type  application/octet-stream;

    #log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
    #                  '$status $body_bytes_sent "$http_referer" '
    #                  '"$http_user_agent" "$http_x_forwarded_for"';

    #access_log  /Users/bisonjames/Programs/laravel/accounts/storage/logs/access.log;
    #error_log   /Users/bisonjames/Programs/laravel/accounts/storage/logs/error.log;
    
    sendfile        on;
    #tcp_nopush     on;

    #keepalive_timeout  0;
    keepalive_timeout  65;

    #gzip  on;


    server {
        listen 80 default_server;
        listen [::]:80 default_server;

        # SSL configuration
        #
        # listen 443 ssl default_server;
        # listen [::]:443 ssl default_server;
        #
        # Note: You should disable gzip for SSL traffic.
        # See: https://bugs.debian.org/773332
        #
        # Read up on ssl_ciphers to ensure a secure configuration.
        # See: https://bugs.debian.org/765782
        #
        # Self signed certs generated by the ssl-cert package
        # Don't use them in a production server!
        #
        # include snippets/snakeoil.conf;

        root /var/www/php;
        # root /var/www/php/public;

        # Add index.php to the list if you are using PHP
        index index.php index.html index.htm index.nginx-debian.html;

        server_name _;
        gzip on;
        gzip_buffers 32 4k;

        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000
        #
        location ~ \.php$ {
            # regex to split $uri to $fastcgi_script_name and $fastcgi_path
            fastcgi_split_path_info ^(.+\.php)(/.+)$;

            # Check that the PHP script exists before passing it
            try_files $fastcgi_script_name =404;

            # Bypass the fact that try_files resets $fastcgi_path_info
            # see: http://trac.nginx.org/nginx/ticket/321
            set $path_info $fastcgi_path_info;
            fastcgi_param PATH_INFO $path_info;

            # With php7.0-cgi alone:
            fastcgi_pass 127.0.0.1:9000;
            # With php7.0-fpm:
            # fastcgi_pass unix:/run/php/php7.0-fpm.sock;

            fastcgi_index index.php;
            include fastcgi.conf;
        }

        location ~ \.(gif|jpg|png)$ {
            gzip off;
        }

	      location ~ \.(css)$ {
        }

	      location ~ \.(js)$ {
        }

        location / {
            include fastcgi.conf;
            fastcgi_split_path_info ^(.+\.php)(/.+)$;
            try_files       $uri $uri/ /index.php?$query_string;
            fastcgi_param   SCRIPT_FILENAME  $document_root/index.php;
            fastcgi_pass    127.0.0.1:9000;
        }

        # deny access to .htaccess files, if Apache's document root
        # concurs with nginx's one
        #
        location ~ /\.ht {
            deny all;
        }
    }
}
